<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<title>OrbitDrawBit</title>
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
    background: #111;
    color: #bbb;
    display: flex;
    flex-flow: column nowrap;
    justify-content: space-between;
    align-content: space-around;
    align-items: center;
    width: 100vw;
  }

  h1 {
    font-size: 1rem;
    font-weight: 100;
    color: #333;
  }

  .drawing {
    width: 98vmin;
    height: 98vmin;
    max-height: 80vh;
    max-width: 80vh;
  }

  form {
    display: flex;
    flex-flow: column wrap;
    justify-content: space-between;
    margin: 0 2vmin 0 2vmin;
    font-size: 3vmin;
  }

  fieldset {
    margin: 0;
    padding: 0;
    border: 0;
    display: flex;
    flex-flow: row wrap;
    justify-content: space-between;
  }

  label.range {
    display: block;
    margin-bottom: 2vmin;
  }

  input[type=range] {
    width: 70vmin;
    margin-left: 2vmin;
    border-radius: 3vmin;
  }

  input[name=e] {
    width: 2ch;
    margin-left: 2vmin;
  }

  input[name=e],
  button {
    border-radius: 3vmin;
    font-size: 3vmin;
    padding: 2vmin;
    background: #999;
  }

  input:focus,
  button:focus {
    box-shadow: 0 0 0 2px #bbb;
    outline: 0;
  }

  footer {
    margin-top: 2vmin;
    font-size: 0.8rem;
    font-weight: 100;
    color: #666;
  }

  a, a:visited, a:focus, a:active {
    color: #335;
  }
</style>
<header>
  <h1>OrbitDrawBit</h1>
</header>
<main>
  <canvas class="drawing" width="1000" height="1000"></canvas>
</main>
<nav>
  <form>
    <label class="range">⚙️1️⃣<input name="r1" type="range" min="1" max="500" step="1"></label>
    <label class="range">⚙️2️⃣<input name="r2" type="range" min="1" max="500" step="1"></label>
    <label class="range">⚙️📏<input name="ro" type="range" min="0" max="1" step="0.1"></label>
    <label class="range">🖌️📏<input name="rs" type="range" min="1" max="50"></label>
    <label class="range">🐢🐇<input name="da" type="range" min="1" max="100" step="1"></label>
    <fieldset>
      <label>🙂<input name="e" type="text" size="2" maxlength="2"></label>
      <button type="button" name="pp" value="pause">⏸️</button>
      <button type="button" name="cl" value="clear">🔁</button>
    </fieldset>
  </form>
</nav>
<footer>
  <a href="https://twitter.com/rowan_m">🖤 @rowan_m</a> <a href="https://glitch.com/edit/#!/orbitdrawbit?path=index.html">💻 code</a>
</footer>
<script>
  'use strict';

  if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    location.protocol = 'https:';
  }

  class Renderer {
    constructor(canvas, scale) {
      this.canvas = canvas;
      this.ctx = this.canvas.getContext('2d');

      this.dCanvas = document.createElement('canvas');
      this.dCtx = this.dCanvas.getContext('2d');
      this.resize(scale);

      this.cur = { x: null, y: null };
      this.prev = { x: null, y: null };

      this.r1 = 460;
      this.r2 = 180;
      this.k = this.r1 / this.r2;
      this.ro = .9;
      this.rs = 10;
      this.da = 0.03;
      this.angle = 0;
      this.color = 0;
      this.e = '🌟';
      this.state = 'playing';

      this.tick = this.tick.bind(this);
      this.toggleState = this.toggleState.bind(this);

      this.resize(scale);
    }

    resize(scale) {
      this.scale = scale;

      this.rescale(this.canvas, this.ctx);
      this.rescale(this.dCanvas, this.dCtx)
      this.postSet();
    }

    rescale(canvas, ctx) {
      canvas.width = 1000 * this.scale;
      canvas.height = 1000 * this.scale;
      ctx.scale(this.scale, this.scale);
    }

    initCtx() {
      this.ctx.lineWidth = 5;
      this.ctx.strokeStyle = 'hsl(0, 0%, 100%, .2)';
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';
    }

    initDCtx() {
      this.dCtx.lineWidth = parseInt(this.rs * 2);
      this.dCtx.textAlign = 'center';
      this.dCtx.textBaseline = 'middle';
    }

    setR1(val) {
      this.r1 = val;
      this.postSet();
    }

    setR2(val) {
      this.r2 = val;
      this.postSet();
    }

    setRs(val) {
      this.rs = val;
      this.postSet();
    }

    setRo(val) {
      this.ro = val;
      this.postSet();
    }

    setDa(val) {
      this.da = val / 1000;
      this.postSet();
    }

    setE(val) {
      this.e = val;
      this.postSet();
    }

    toggleState() {
      if (this.state === 'playing') {
        this.state = 'paused';
      } else {
        this.state = 'playing';
        window.requestAnimationFrame(this.tick);
      }
    }

    postSet() {
      this.initCtx();
      this.initDCtx();

      if (this.state === 'paused') {
        this.render();
      }
    }

    clear() {
      this.dCtx.clearRect(0, 0, 1000, 1000);
      this.render();
    }

    tick() {
      this.render();

      if (this.state === 'playing') {
        this.angle += this.da;
        window.requestAnimationFrame(this.tick);
      }
    }

    render() {
      this.dCtx.save();
      this.dCtx.translate(500, 500);
      this.dCtx.rotate(this.angle);
      this.dCtx.translate(this.r1 - this.r2, 0);
      this.dCtx.rotate(-(this.angle * this.r1) / this.r2);
      this.dCtx.translate(this.r2 * this.ro, 0);
      this.dCtx.strokeStyle = `hsl(${this.angle * 180 / Math.PI}, 100%, 70%)`;
      this.dCtx.beginPath();
      this.dCtx.ellipse(0, 0, this.rs, this.rs, 0, 0, 2 * Math.PI);
      this.dCtx.stroke();
      this.dCtx.restore();

      this.ctx.clearRect(0, 0, 1000, 1000);
      this.ctx.drawImage(this.dCanvas, 0, 0, 1000, 1000);

      this.ctx.save();

      this.ctx.translate(500, 500);

      this.ctx.beginPath();
      this.ctx.setLineDash([15, ((2 * Math.PI * this.r1) / 60) - 15]);
      this.ctx.ellipse(0, 0, this.r1, this.r1, 0, 0, 2 * Math.PI);
      this.ctx.stroke();

      this.ctx.rotate(this.angle);
      this.ctx.translate(this.r1 - this.r2, 0);
      this.ctx.rotate(-(this.angle * this.r1) / this.r2);

      this.ctx.beginPath();
      this.ctx.setLineDash([15, ((2 * Math.PI * this.r2) / 60) - 15]);;
      this.ctx.ellipse(0, 0, this.r2, this.r2, 0, 0, 2 * Math.PI);
      this.ctx.stroke();

      this.ctx.translate(this.r2 * this.ro, 0);

      this.ctx.setLineDash([5, ((2 * Math.PI * this.rs * 5) / 8) - 5]);
      this.ctx.beginPath();
      // this.ctx.ellipse(0, 0, this.rs * 5, this.rs * 5, 0, 0, 2 * Math.PI);
      this.ctx.font = `${this.rs * 8}px sans`;
      this.ctx.fillText(this.e, 0, 0);
      this.ctx.stroke();

      this.ctx.restore();
    }
  }

  const baseCanvas = document.querySelector('.drawing');
  const initScale = baseCanvas.getBoundingClientRect().width / 1000;
  const renderer = new Renderer(baseCanvas, initScale);

  document.querySelector('input[name=r1]').value = renderer.r1;
  document.querySelector('input[name=r2]').value = renderer.r2;
  document.querySelector('input[name=rs]').value = renderer.rs;
  document.querySelector('input[name=ro]').value = renderer.ro;
  document.querySelector('input[name=da]').value = renderer.da * 1000;
  document.querySelector('input[name=e]').value = renderer.e;

  window.addEventListener('resize', (e) => { renderer.resize(baseCanvas.getBoundingClientRect().width / 1000); });

  document.querySelector('input[name=r1]').addEventListener('input', (e) => { renderer.setR1(e.target.value); });
  document.querySelector('input[name=r2]').addEventListener('input', (e) => { renderer.setR2(e.target.value); });
  document.querySelector('input[name=rs]').addEventListener('input', (e) => { renderer.setRs(e.target.value); });
  document.querySelector('input[name=ro]').addEventListener('input', (e) => { renderer.setRo(e.target.value); });
  document.querySelector('input[name=da]').addEventListener('input', (e) => { renderer.setDa(e.target.value); });
  document.querySelector('input[name=e]').addEventListener('focus', (e) => { e.target.select(); });
  document.querySelector('input[name=e]').addEventListener('mouseup', (e) => { return false; });
  document.querySelector('input[name=e]').addEventListener('input', (e) => { renderer.setE(e.target.value); });
  document.querySelector('button[name=pp]').addEventListener('click', (e) => {
    renderer.toggleState();

    if (renderer.state === 'playing') {
      e.target.textContent = '⏸️';
    } else {
      e.target.textContent = '▶️';
    }
  });
  document.querySelector('button[name=cl]').addEventListener('click', (e) => { renderer.clear(); });

  window.requestAnimationFrame(renderer.tick);
</script>