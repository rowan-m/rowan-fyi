---
import MinLayout from "@/layouts/MinimumLayout.astro";
---

<MinLayout title="Musaic Box" description="Provide vibe, receive tune.">
  <link
    rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸµ</text></svg>"
  />
  <meta
    http-equiv="origin-trial"
    content="Av3dk6PxjvxZ/k9wKbOs+/kUdN0mlFCqEtqj+p8N13bBgTvIglBp1Uv2UgdwiVBTDKJIf8sk6hG/Z3ClME6NNQ8AAABdeyJvcmlnaW4iOiJodHRwczovL3Jvd2FuLmZ5aTo0NDMiLCJmZWF0dXJlIjoiQUlQcm9tcHRBUElNdWx0aW1vZGFsSW5wdXQiLCJleHBpcnkiOjE3NzQzMTA0MDB9"
  />
  <style>
    :root {
      font-family: "Georgia", serif;
      font-synthesis: none;
      text-rendering: optimizeLegibility;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      color: #5a4a3a;
    }

    body {
      margin: 0;
      padding: 5vh 2rem 2rem 2rem;
      min-height: 100vh;
      background: linear-gradient(135deg, #fdf8e1 0%, #e8dccb 100%);
    }

    main {
      display: flex;
      flex-flow: column wrap;
      place-items: center;
      gap: 1rem;
      max-width: 500px;
      margin: 0 auto;
      text-align: center;
      position: relative;
    }

    h1 {
      font-size: 2.5rem;
      margin: 0;
      color: #8b4513;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }

    div {
      line-height: 1.5;
    }

    a {
      color: #4a69bb;
      text-decoration: none;
      border-bottom: 1px dotted #4a69bb;
    }

    a:hover {
      color: #2e4a8d;
      border-bottom: 1px solid #2e4a8d;
    }

    label {
      font-weight: bold;
      margin-top: 1rem;
    }

    input[type="text"] {
      padding: 0.6rem 1rem;
      border: 1px solid #d4c2a8;
      border-radius: 8px;
      font-size: 1rem;
      width: 250px;
      max-width: 80%;
      box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.05);
    }

    button {
      background-color: #a8d4c2;
      color: #5a4a3a;
      border: none;
      border-radius: 8px;
      padding: 0.7rem 1.5rem;
      font-size: 1.1rem;
      cursor: pointer;
      transition:
        background-color 0.2s ease,
        transform 0.1s ease;
      box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.1);
    }

    button:hover:not(:disabled) {
      background-color: #8cc7b0;
      transform: translateY(-2px);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.1);
    }

    button:disabled {
      background-color: #e0e0e0;
      color: #a0a0a0;
      cursor: not-allowed;
      box-shadow: none;
    }

    .note {
      display: inline-block;
      font-size: 1.5rem;
    }

    .cog {
      display: inline-block;
      animation: spin 4s linear infinite;
      font-size: 1.5rem;
    }

    .hidden {
      display: none !important;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    @keyframes bounce {
      0%,
      100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-8px);
      }
    }

    #playable-status.playing .note {
      animation: bounce 1.5s infinite ease-in-out;
    }

    #playable-status.playing .note:nth-child(1) {
      animation-delay: 0s;
    }

    #playable-status.playing .note:nth-child(2) {
      animation-delay: 0.25s;
    }

    #playable-status.playing .note:nth-child(3) {
      animation-delay: 0.5s;
    }

    dialog {
      border: 2px solid #d4c2a8;
      border-radius: 10px;
      box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2);
      padding: 1.5rem;
      background-color: #fffef7;
      color: #5a4a3a;
    }

    dialog > div {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    dialog::backdrop {
      background-color: rgba(0, 0, 0, 0.4);
    }

    dialog button {
      margin-top: 1rem;
      background-color: #d4c2a8;
    }

    dialog button:hover:not(:disabled) {
      background-color: #c2b09a;
    }
  </style>
  <main>
    <h1>Musaic Box</h1>
    <div>
      Use <a href="https://developer.chrome.com/docs/ai/built-in"
        >Chrome's built-in AI</a
      > and <a href="https://tonejs.github.io/">Tone.js</a> to power a music box.
    </div>
    <div>Enter a vibe and generate.</div>
    <label>Vibe: <input type="text" name="vibe" /></label>
    <button type="button" name="generate" disabled>ğŸ¶ Generate</button>
    <button type="button" name="playpause" disabled>â¯ Play / pause</button>
    <div id="generating-status" class="hidden">
      <span class="cog">âš™</span>
      Generating your "<span class="chosen-vibe"></span>" tune...
    </div>
    <div id="playable-status" class="hidden">
      <span class="note">ğŸµ</span>
      <span class="note">ğŸµ</span>
      <span class="note">ğŸµ</span>
      "<span class="chosen-vibe"></span>" tune
      <span>generated</span>! Press Play.
    </div>
  </main>
  <dialog id="download-status">
    <div>
      <div>One-time model download required. Warning: may take a while!</div>
      <button name="download" disabled>Download model</button>
      <output>Downloaded: <span id="download-percent">0.00</span>%</output>
    </div>
  </dialog>
  <dialog id="not-supported-status">
    <div>
      <div>
        It looks like the on-device Prompt API is not supported on this device.
      </div>
      <div>You can still play generated melodies though!</div>
      <form method="dialog">
        <button>OK</button>
      </form>
    </div>
  </dialog>

  <script type="module">
    import * as Tone from "https://cdn.jsdelivr.net/npm/tone@15.1.22/+esm";
    const SYSTEM_PROMPT = `
You are a clever, playful, and novel music composer who creates original short tunes based on a suggested vibe or mood from the user.

You provide your output as JSON specifying the note in scientific pitch notation, and its duration in seconds.

Look at the example lines to understand the format for individual notes:
{ "note": "F4", "duration": ".5" }
Plays F in the 4 octave for a half of a second.

{ "note": "D#1", "duration": "1" }
Plays D sharp in the first octave for one second.

{ "note": "Fb2", "duration": ".25" }
Plays F flat in the second octave for a quarter second.

A valid note matches the regular expression ^[A-G][#b]?\\d+$
Start with a letter from "A", "B", "C", "D", "E", "F", or "G". Then an optional "#" for sharp notes or "b" for flat notes. End with a number from 0-9 for the octave.

Your tune should be approximately 20 notes or fewer.`;

    const playableStatus = document.querySelector("#playable-status");
    const generatingStatus = document.querySelector("#generating-status");
    const chosenVibeText = document.querySelectorAll(".chosen-vibe");
    const playPauseButt = document.querySelector('button[name="playpause"]');
    const generateButt = document.querySelector('button[name="generate"]');
    const downloadDialog = document.querySelector("#download-status");
    const downloadButt = document.querySelector('button[name="download"]');
    const downloadPercent = document.querySelector("#download-percent");
    const notSupportedDialog = document.querySelector("#not-supported-status");
    let synth, part, model;

    playPauseButt.addEventListener("click", playMusic);
    generateButt.addEventListener("click", generate);

    const modelSupported = "LanguageModel" in self;
    if (!modelSupported) {
      notSupportedDialog.showModal();
    } else {
      const modelAvailability = await LanguageModel.availability({
        expectedInputs: [{ type: "text", languages: ["en"] }],
        expectedOutputs: [{ type: "text", languages: ["en"] }],
      });

      console.log("Model availability: ", modelAvailability);

      if (modelAvailability === "downloading") {
        downloadDialog.showModal();
        createModel();
      }

      if (modelAvailability === "downloadable") {
        downloadDialog.showModal();
        downloadButt.addEventListener("click", createModel);
        downloadButt.disabled = false;
      }

      if (modelAvailability === "available") {
        createModel();
      }
    }

    const schema = {
      type: "object",
      properties: {
        notes: {
          type: "array",
          minItems: 1,
          items: {
            type: "object",
            properties: {
              note: { type: "string" },
              duration: { type: "number" },
            },
            required: ["note", "duration"],
          },
        },
      },
    };

    async function createModel() {
      generateButt.disabled = true;
      downloadButt.textContent = "Downloading...";
      downloadButt.disabled = true;

      model = await LanguageModel.create({
        monitor(m) {
          m.addEventListener("downloadprogress", (e) => {
            const loaded = (parseFloat(e.loaded * 100)).toFixed(2);
            downloadPercent.textContent = loaded;
            if (loaded >= 100) {
              downloadButt.disabled = true;
              downloadDialog.close();
            }
          });
        },
        initialPrompts: [{ role: "system", content: SYSTEM_PROMPT }],
        expectedInputs: [{ type: "text", languages: ["en"] }],
        expectedOutputs: [{ type: "text", languages: ["en"] }],
      });
      console.log("System prompt: ", SYSTEM_PROMPT);
      generateButt.disabled = false;
    }

    async function generate(e) {
      const vibe = document.querySelector('input[name="vibe"]').value;
      generatingStatus.classList.remove("hidden");
      playableStatus.classList.add("hidden");
      chosenVibeText.forEach((el) => (el.textContent = vibe));
      generateButt.disabled = true;

      try {
        console.log(
          "User prompt: ",
          `Create a melody based on the vibe: ${vibe}`
        );
        const result = await model.prompt(
          `Create a melody based on the vibe: ${vibe}`,
          { responseConstraint: { schema } }
        );
        const generated = JSON.parse(result);
        console.log("Generated notes: ", generated.notes);
        const notes = generated.notes;

        const url = new URL(window.location);
        url.searchParams.set("vibe", vibe);
        url.searchParams.set("notes", JSON.stringify(notes));
        window.history.pushState({}, "", url);

        scheduleMelody(notes);
      } catch (error) {
        console.error("Error generating music:", error);
        alert("Failed to generate music. See console for details.");
      }

      generatingStatus.classList.add("hidden");
      playableStatus.classList.remove("hidden");
      chosenVibeText.forEach((el) => (el.textContent = vibe));
      playPauseButt.disabled = false;
      generateButt.disabled = false;
    }

    function scheduleMelody(notes) {
      // If a part already exists, stop and dispose of it to avoid overlap
      if (part) {
        part.stop();
        part.dispose();
      }

      let currentTime = 0;
      const partNotes = notes.map((note) => {
        const noteEvent = {
          time: currentTime,
          note: note.note,
          duration: note.duration,
        };
        currentTime += parseFloat(note.duration);
        return noteEvent;
      });

      part = new Tone.Part((time, value) => {
        if (!/^[A-G][#b]?\d+$/.test(value.note)) {
          console.log("Skipping invalid note:", value.note);
          return;
        }
        synth.triggerAttackRelease(value.note, value.duration, time);
      }, partNotes).start(0);

      part.loop = true;
      part.loopEnd = currentTime + 1;
    }

    function playMusic(e) {
      if (Tone.getTransport().state !== "started") {
        Tone.getTransport().start();
        playableStatus.classList.add("playing");
      } else {
        Tone.getTransport().stop();
        Tone.getTransport().position = 0;
        playableStatus.classList.remove("playing");
      }
    }

    async function init() {
      synth = new Tone.FMSynth({
        harmonicity: 3.5,
        modulationIndex: 15,
        detune: 2400,
        envelope: {
          attack: 0.001,
          decay: 1.4,
          sustain: 0,
          release: 1.4,
        },
        modulationEnvelope: {
          attack: 0.002,
          decay: 0.8,
          sustain: 0,
          release: 0.8,
        },
      }).toDestination();

      const eq = new Tone.EQ3({
        low: -12,
        mid: -2,
        high: 10,
      }).toDestination();

      const delay = new Tone.PingPongDelay("16n", 0.1).toDestination();
      delay.wet.value = 0.05;

      const reverb = new Tone.Reverb({
        decay: 0.6,
        wet: 0.15,
      }).toDestination();

      synth.chain(eq, delay, reverb);

      const urlParams = new URLSearchParams(window.location.search);
      const vibeParam = urlParams.get("vibe");
      const notesParam = urlParams.get("notes");

      if (vibeParam && notesParam) {
        document.querySelector('input[name="vibe"]').value = vibeParam;
        try {
          const notes = JSON.parse(notesParam);
          scheduleMelody(notes);
          generatingStatus.classList.add("hidden");
          playableStatus.classList.remove("hidden");
          chosenVibeText.forEach((el) => (el.textContent = vibeParam));
          playPauseButt.disabled = false;
        } catch (error) {
          console.error("Error parsing notes from URL:", error);
          alert("Could not load melody from URL. See console for details.");
        }
      }
    }

    (async () => {
      init();
    })();
  </script>
</MinLayout>
