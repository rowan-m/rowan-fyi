---
import MinLayout from "@/layouts/MinimumLayout.astro";
---

<MinLayout title="Musaic Box" description="Provide vibe, receive tune.">
  <link
    rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéµ</text></svg>"
  />
  <meta
    http-equiv="origin-trial"
    content="Av3dk6PxjvxZ/k9wKbOs+/kUdN0mlFCqEtqj+p8N13bBgTvIglBp1Uv2UgdwiVBTDKJIf8sk6hG/Z3ClME6NNQ8AAABdeyJvcmlnaW4iOiJodHRwczovL3Jvd2FuLmZ5aTo0NDMiLCJmZWF0dXJlIjoiQUlQcm9tcHRBUElNdWx0aW1vZGFsSW5wdXQiLCJleHBpcnkiOjE3NzQzMTA0MDB9"
  />
  <style>
    :root {
      font-family: system-ui, sans-serif;
      font-synthesis: none;
      text-rendering: optimizeLegibility;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    main {
      display: flex;
      flex-flow: column wrap;
      place-items: center;
      gap: 0.5rem;
    }

    h1 {
      font-size: 1rem;
      margin: 0;
    }
  </style>
  <main>
    <h1>Musaic Box</h1>
    <dialog id="not-supported">
      It looks like the on-device Prompt API is not supported on this device.
      You can check the hardware requirements and try enabling
      <code>chrome://flags/#prompt-api-for-gemini-nano</code> and
      <code>chrome://flags/#enable-experimental-web-platform-features</code>.
      You can still play generated melodies though!
      <form method="dialog">
        <button>OK</button>
      </form>
    </dialog>
    <dialog id="download-status">
      <button name="download" disabled>Download model</button><output
        >Downloaded: <span id="download-percent">0</span>%</output
      >
    </dialog>
    <p id="status">Enter a vibe and generate.</p>
    <label>Vibe <input type="text" name="vibe" /></label>
    <button type="button" name="generate" disabled>üé∂ Generate</button>
    <button type="button" name="playpause" disabled>‚èØ Play / pause</button>
  </main>
  <script type="module">
    import * as Tone from "https://cdn.jsdelivr.net/npm/tone@15.1.22/+esm";
    const SYSTEM_PROMPT = `
You are a clever, playful, and novel music composer who creates original short tunes based on a suggested vibe or mood from the user.

You provide your output as JSON specifying the note in scientific pitch notation, and its duration in seconds.

Look at the example lines to understand the format for individual notes:
{ "note": "F4", "duration": ".5" }
Plays F in the 4 octave for a half of a second.

{ "note": "D#1", "duration": "1" }
Plays D sharp in the first octave for one second.

{ "note": "Fb2", "duration": ".25" }
Plays F flat in the second octave for a quarter second.

Use a "b" to represent the flat symbol.
A note always starts with the letter. NEVER start a note with a "." character. These are INVALID notes ".F#2", ".b1", ".Bb1"

Your tune should be approximately 20 notes or fewer.`;

    const notSupportedDialog = document.querySelector("#not-supported");
    const statusText = document.querySelector("#status");
    const downloadDialog = document.querySelector("#download-status");
    const downloadButt = document.querySelector('button[name="download"]');
    const downloadPercent = document.querySelector("#download-percent");
    const playPauseButt = document.querySelector('button[name="playpause"]');
    const generateButt = document.querySelector('button[name="generate"]');

    let synth, part, model;

    playPauseButt.addEventListener("click", playMusic);
    generateButt.addEventListener("click", generate);

    const modelSupported = "LanguageModel" in self;
    if (!modelSupported) {
      notSupportedDialog.showModal();
    } else {
      const modelAvailability = await LanguageModel.availability({
        expectedInputs: [{ type: "text", languages: ["en"] }],
        expectedOutputs: [{ type: "text", languages: ["en"] }],
      });

      console.log("Model availability: ", modelAvailability);

      if (modelAvailability === "downloading") {
        downloadDialog.showModal();
        createModel();
      }

      if (modelAvailability === "downloadable") {
        downloadDialog.showModal();
        downloadButt.addEventListener("click", createModel);
        downloadButt.disabled = false;
      }

      if (modelAvailability === "available") {
        createModel();
      }
    }

    const schema = {
      type: "object",
      properties: {
        notes: {
          type: "array",
          minItems: 1,
          items: {
            type: "object",
            properties: {
              note: { type: "string" },
              duration: { type: "number" },
            },
            required: ["note", "duration"],
          },
        },
      },
    };

    async function createModel() {
      generateButt.disabled = true;
      downloadButt.textContent = "Downloading...";
      downloadButt.disabled = true;

      model = await LanguageModel.create({
        monitor(m) {
          m.addEventListener("downloadprogress", (e) => {
            const loaded = Math.round(parseFloat(e.loaded * 100));
            downloadPercent.textContent = loaded;
            if (loaded >= 100) {
              downloadButt.disabled = true;
              downloadDialog.close();
            }
          });
        },
        initialPrompts: [{ role: "system", content: SYSTEM_PROMPT }],
        expectedInputs: [{ type: "text", languages: ["en"] }],
        expectedOutputs: [{ type: "text", languages: ["en"] }],
      });
      console.log("System prompt: ", SYSTEM_PROMPT);
      generateButt.disabled = false;
    }

    async function generate(e) {
      const vibe = document.querySelector('input[name="vibe"]').value;
      statusText.textContent = `Generating your "${vibe}" tune...`;
      generateButt.disabled = true;

      try {
        console.log("User prompt: ", `Create a melody based on the vibe: ${vibe}`);
        const result = await model.prompt(
          `Create a melody based on the vibe: ${vibe}`,
          { responseConstraint: { schema } }
        );
        const generated = JSON.parse(result);
        console.log("Generated notes: ", generated.notes);
        const notes = generated.notes;

        const url = new URL(window.location);
        url.searchParams.set("vibe", vibe);
        url.searchParams.set("notes", JSON.stringify(notes));
        window.history.pushState({}, "", url);

        scheduleMelody(notes);
      } catch (error) {
        console.error("Error generating music:", error);
        alert("Failed to generate music. See console for details.");
      }

      statusText.textContent = `Generated! Press play.`;
      playPauseButt.disabled = false;
      generateButt.disabled = false;
    }

    function scheduleMelody(notes) {
      // If a part already exists, stop and dispose of it to avoid overlap
      if (part) {
        part.stop();
        part.dispose();
      }

      let currentTime = 0;
      const partNotes = notes.map((note) => {
        const noteEvent = {
          time: currentTime,
          note: note.note,
          duration: note.duration,
        };
        currentTime += parseFloat(note.duration);
        return noteEvent;
      });

      part = new Tone.Part((time, value) => {
        synth.triggerAttackRelease(value.note, value.duration, time);
      }, partNotes).start(0);

      part.loop = true;
      part.loopEnd = currentTime + 1;
    }

    function playMusic(e) {
      if (Tone.getTransport().state !== "started") {
        Tone.getTransport().start();
      } else {
        Tone.getTransport().stop();
        Tone.getTransport().position = 0;
      }
    }

    async function init() {
      synth = new Tone.FMSynth({
        harmonicity: 3.5,
        modulationIndex: 15,
        detune: 2400,
        envelope: {
          attack: 0.001,
          decay: 1.4,
          sustain: 0,
          release: 1.4,
        },
        modulationEnvelope: {
          attack: 0.002,
          decay: 0.8,
          sustain: 0,
          release: 0.8,
        },
      }).toDestination();

      const eq = new Tone.EQ3({
        low: -12,
        mid: -2,
        high: 10,
      }).toDestination();

      const delay = new Tone.PingPongDelay("16n", 0.1).toDestination();
      delay.wet.value = 0.05;

      const reverb = new Tone.Reverb({
        decay: 0.6,
        wet: 0.15,
      }).toDestination();

      synth.chain(eq, delay, reverb);

      const urlParams = new URLSearchParams(window.location.search);
      const vibeParam = urlParams.get("vibe");
      const notesParam = urlParams.get("notes");

      if (vibeParam && notesParam) {
        document.querySelector('input[name="vibe"]').value = vibeParam;
        try {
          const notes = JSON.parse(notesParam);
          scheduleMelody(notes);
          statusText.textContent = `Loaded "${vibeParam}" tune! Press play.`;
          playPauseButt.disabled = false;
        } catch (error) {
          console.error("Error parsing notes from URL:", error);
          alert("Could not load melody from URL. See console for details.");
        }
      }
    }

    (async () => {
      init();
    })();
  </script>
</MinLayout>
